digraph g{

# name must start by "cluster" if we want border
subgraph clustertcp_fallback {
label="TCP FSM";
esta [label="ESTAB"]
color=blue;
graph[style=dotted];
}

subgraph clustermptcp {
label="Meta";
node [shape=diamond]
if_contiguous_data [label="Contiguous data"];

# active nb of subflows
if_subflow_nb [label="Number of subflows"];

node [shape=rectangle]
m_listen [label="M_LISTEN"]
m_syn_sent [label="M_SYN_SENT"]
m_syn_rcvd [label="M_SYN_RCVD"]

m_esta_sp [label="ESTAB (M_ESTA_SP)"]
m_esta_mp [label="M_ESTA_MP"]
m_esta_wait [label="M_ESTA_WAIT"]

# could link to a subgraph/cluster
m_on_dfin [label="See appendix C"]
m_on_fin [label="See TCP FSM"]

m_closed [label="M_CLOSED"]

m_fastclose [label="M_FASTCLOSE_WAIT"]

syn_rcvd [label="Fallback to TCP"]


}




m_listen -> syn_rcvd [label="SYN"]
m_listen -> m_syn_rcvd [label="Rcv SYN + MP_CAPABLE\nMaster subflow established"]

m_syn_sent -> m_syn_rcvd [label="Rcv SYN+MP_CAPABLE"]
m_syn_sent -> esta [label="Rcv SYN+ACK"]

m_syn_rcvd -> m_esta_wait [label="ACK + MP_CAPABLE"]
m_syn_rcvd -> esta [label="ACK"]

if_subflow_nb -> if_contiguous_data [label="=1"];
if_subflow_nb -> m_esta_mp [label=">1\nSnd RST"]
if_contiguous_data -> m_esta_mp [label="yes\nSnd infinite mapping"]
if_contiguous_data -> m_esta_mp [label="no\nSnd RST+MP_FAIL"]

m_esta_wait -> m_esta_mp [label="Recv DACK within constraints"]
m_esta_wait -> m_esta_sp [label="No DACK within constraints"]

m_esta_sp -> m_on_fin [label="Recv FIN"]

m_esta_mp -> if_subflow_nb [label="MP_FAIL"]

m_esta_mp -> m_on_dfin [label="Recv DFIN"]
m_esta_mp -> m_fastclose [label="Close all subflows but 1\nSnd MP_FASTCLOSE on remaining sf"]

m_esta_mp -> m_esta_mp [label="Rcv SYN + MP_JOIN"]
m_esta_mp -> m_esta_mp [label="Active open\nSnd SYN + MP_JOIN"]

m_esta_mp -> m_closed [label="Rcv MP_FASTCLOSE\nSnd RST"]

m_fastclose -> m_closed [label="Rcv MP_FASTCLOSE\nSnd RST"]
m_fastclose -> m_closed [label="Rcv RST"]

m_closed -> m_syn_sent [label="Active open\nSnd SYN+MP_CAPABLE"]
m_closed -> m_listen [label="Passive open"]

}
